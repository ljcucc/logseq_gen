import configparser
import os
import sys
from pathlib import Path
from typing import Iterator

# --- Constants ---
ROOT_DIR = Path(__file__).parent.resolve()
ASSETS_DIR = ROOT_DIR / "assets"
PAGES_DIR = ROOT_DIR / "pages"
GENERATED_MARKER = "generated:: true"

# --- Helper Functions ---

def is_generated_file(file_path: Path) -> bool:
    """Checks if a file is marked as generated by reading its first line."""
    try:
        with file_path.open('r', encoding='utf-8') as f:
            first_line = f.readline()

        # Process the line outside the 'with' block
        cleaned_line = first_line.strip()
        parts = [part.strip() for part in cleaned_line.split("::", 1)]
        return len(parts) == 2 and parts[0] == "generated" and parts[1] == "true"
    except (IOError, IndexError):
        # Catches file not found, empty file, etc.
        return False

def find_ini_files() -> Iterator[Path]:
    """Finds all 'index.ini' files within the assets directory."""
    return ASSETS_DIR.rglob("index.ini")

# --- Core Functions ---

def clear_build():
    """Removes all Markdown files in the pages directory marked as generated."""
    if not PAGES_DIR.exists():
        print("Pages directory does not exist. Nothing to clear.")
        return

    print(f"Clearing generated files from {PAGES_DIR}...")
    for md_file in PAGES_DIR.glob("*.md"):
        if not is_generated_file(md_file): continue
        md_file.unlink()
        print(f"Removed {md_file.name}")
    print("Clear build finished.")

def process_ini_file(ini_path: Path):
    """Processes a single index.ini file to generate a corresponding page."""
    print(f"Processing: {ini_path.relative_to(ROOT_DIR)}")
    config = configparser.ConfigParser()
    config.read(ini_path, encoding='utf-8')

    # 1. Validate header and get content file path
    if not config.has_option("header", "content"):
        raise ValueError("Missing 'content' option in [header] section.")

    content_filename = config.get("header", "content").strip('"' )
    content_filepath = ini_path.parent / content_filename

    if not content_filepath.exists():
        raise FileNotFoundError(f"Content file '{content_filepath}' not found.")

    # 2. Read content and properties
    md_content = content_filepath.read_text(encoding='utf-8')
    properties = [f"{key}:: {value}" for key, value in config.items("properties")]

    # 3. Construct the output content
    output_content = [GENERATED_MARKER, *properties]
    final_content = "\n".join(output_content) + "\n\n" + md_content

    # 4. Determine output path and write file
    relative_path = ini_path.parent.relative_to(ASSETS_DIR)
    output_filename_base = "index" if str(relative_path) == "." else str(relative_path).replace(os.sep, "___")
    output_filepath = PAGES_DIR / f"{output_filename_base}.md"

    output_filepath.write_text(final_content, encoding='utf-8')
    print(f"-> Generated {output_filepath.relative_to(ROOT_DIR)}")

def build_markdown():
    """Generates Markdown pages from all found index.ini files."""
    clear_build()
    PAGES_DIR.mkdir(exist_ok=True)

    print(f"\nStarting build process from {ASSETS_DIR}...")
    for ini_path in find_ini_files():
        try:
            process_ini_file(ini_path)
        except (ValueError, FileNotFoundError, configparser.Error) as e:
            print(f"[SKIP] Could not process {ini_path.relative_to(ROOT_DIR)}: {e}", file=sys.stderr)
    print("\nBuild process finished.")

# --- Main Execution ---

def main():
    """Main entry point for the script."""
    # Create a simple command-line interface
    commands = {
        "build": build_markdown,
        "clear": clear_build,
    }

    # Get command from args, default to 'build'
    command = sys.argv[1].lower() if len(sys.argv) > 1 else "build"

    action = commands.get(command)
    if action:
        action()
    else:
        print(f"Unknown command: {command}", file=sys.stderr)
        print(f"Usage: python {sys.argv[0]} [build|clear]", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
